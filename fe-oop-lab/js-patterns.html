<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>JS Patterns</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/simple.css">

    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro&display=swap" rel="stylesheet">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/vs.css">

    <link rel="stylesheet" href="css/js-patterns.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>

<div class="wrapper">
    <header class="mainheader">
        <div class="logo">
            <div class="divider"><img src="./img/js-patterns/EPAM_LOGO_WhiteAndBlue.png"></div>
            <a href="#/"><span class="logotext">JS Patterns</span></a>
        </div>
    </header>
</div>

<div class="reveal">
    <div class="slides">

        <!--Intro-->
        <!--    <section>-->

        <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background">
            <h1>JavaScript</h1>
            <h2>Design Patterns</h2>
        </section>

        <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background">
            <h2>What is Pattern</h2>
            <p class="stretch">
                <img class="plain" src="img/js-patterns/wiki-general.png" alt="blinds gif">
            </p>

            <aside class="notes">
                Реугялрно повторювана сутність в житті, мистецтві чи абстрактних ідеях.
                Геометричний паттерн - фігури.
            </aside>
        </section>

        <section>
            <h2>What is Software Design Pattern?</h2>
            <ul>
                <li class="fragment fade-up">
                    Typical solution to commonly occurring problem in software design
                </li>
                <li class="fragment fade-up">
                    Pre-made blueprints that you can customize and use in your code
                </li>
                <li class="fragment fade-up">
                    Not a library or code snippet
                </li>
                <li class="fragment fade-up">
                    Not an algorithm
                </li>
                <li class="fragment fade-up">
                    Blueprint, not a recipe
                </li>
            </ul>

            <aside class="notes">
                Патерн проектування — це типовий спосіб вирішення певної проблеми, що часто зустрічається при проектуванні архітектури програм.
                <br/>
                На відміну від готових функцій чи бібліотек, патерн не можна просто взяти й скопіювати в програму. Патерн являє собою не якийсь конкретний код, а загальний принцип вирішення певної проблеми, який майже завжди треба підлаштовувати для потреб тієї чи іншої програми.
                <br/>
                Патерни часто плутають з алгоритмами, адже обидва поняття описують типові рішення відомих проблем. Але якщо алгоритм — це чіткий набір дій, то патерн — це високорівневий опис рішення, реалізація якого може відрізнятися у двох різних програмах.
                <br/>
                Якщо провести аналогії, то алгоритм — це кулінарний рецепт з чіткими кроками, а патерн — інженерне креслення, на якому намальовано рішення без конкретних кроків його отримання.
            </aside>

        </section>

<!--        <section>
            <h2>What does Pattern consist of?</h2>
            <ul>
                <li class="fragment fade-up">
                    <u>Intent</u> of the pattern briefly describes both the problem and the solution.
                </li>
                <li class="fragment fade-up">
                    <u>Motivation</u> further explains the problem and the solution the pattern makes possible.
                </li>
                <li class="fragment fade-up">
                    <u>Structure</u> of classes shows each part of the pattern and how they are related.
                </li>
                <li class="fragment fade-up">
                    <u>Code example</u> makes it easier to grasp the idea behind the pattern.
                </li>
            </ul>

            <aside class="notes">
            </aside>
        </section>-->

        <section>
            <h3>Who invented patterns?</h3>

            <ul>
                <li class="fragment fade-up">Patterns are discovered, not invented</li>
                <li class="fragment fade-up">Repeated solution -> Detailed description -> Name</li>
                <li class="fragment fade-up">1977 - Christopher Alexander. A Pattern Language: Towns, Buildings, Construction</li>
                <li class="fragment fade-up">
                    1994 - Design Patterns: Elements of Reusable Object-Oriented Software - <u>23 patterns</u>
                </li>
                <li class="fragment fade-up">The GoF book</li>
            </ul>
            
            
            <aside class="notes">
                Шаблони проєктування: Елементи повторно використовуваного об'єктно-орієнтованого програмного забезпечення
            </aside>
        </section>

        <section>
            <h3>Why should I learn patterns?</h3>

            <ul>
                <li class="fragment fade-up">Verified and tested solutions</li>
                <li class="fragment fade-up">Standardized code</li>
                <li class="fragment fade-up">Common Developer Language</li>
            </ul>

            <aside class="notes">
                Можна не знати. Скоріш за все реалізуєете якісь паттерни несвідомо
                <br>
                Перевірені рішення - велосипед
                <br>
                Стандартизація коду
                <br>
                Називаєте паттерн, а не пояснюєте архітектуру
            </aside>
        </section>

        <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background" >
            <h2>Patterns - the hard way</h2>
            <p class="stretch">
                <img class="plain" src="img/angular_bad_pract/blindssuck.gif" alt="blinds gif">
            </p>
        </section>

        <section>
            <h3>Pattern Types</h3>
            <ul>
                <li class="fragment fade-up">Creational</li>
                <li class="fragment fade-up">Structural</li>
                <li class="fragment fade-up">Behavioral</li>
            </ul>

            <aside class="notes">
                <ul>
                    <li>Породжуючі патерни піклуються про гнучке створення об’єктів без внесення в програму зайвих
                        залежностей.
                    </li>
                    <li>
                        Структурні патерни показують різні способи побудови зв’язків між об’єктами.
                    </li>
                    <li>
                        Поведінкові патерни піклуються про ефективну комунікацію між об’єктами.
                    </li>
                </ul>
            </aside>
        </section>

        <section>
            <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background">
                <h2>Module Pattern</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/module.jpg" alt="blinds gif">
                </p>
            </section>

            <section>
                <table style="width:100%;">
                    <tr>
                        <td>
                            <pre><code class="hljs typescript data-trim has-highlights">
var message = "Hello";

function showMessage() {
    alert( message );
}

showMessage();
                </code></pre>
                        </td>
                        <td class="fragment fade-right">
                            <pre class="fragment fade-down"><code class="hljs typescript data-trim has-highlights">
&lt;script&gt;
    var message = &quot;Press the button&quot;;
&lt;/script&gt;
                            </code></pre>

                            <pre class=""><code class="hljs typescript data-trim has-highlights">
&lt;script src=&quot;hello.js&quot;&gt;&lt;/script&gt;
                            </code></pre>
                            <pre class="fragment fade-up"><code class="hljs typescript data-trim has-highlights">
&lt;button&gt;Button&lt;/button&gt;
&lt;script&gt;
    alert( message ); // "Press the button" is expected
&lt;/script&gt;
                </code></pre>
                        </td>
                    </tr>
                </table>

                <pre class="fragment fade-up"><code class="hljs typescript data-trim has-highlights">
                (function() {
                    var message = "Hello";
                    function showMessage() {
                        alert( message );
                    }

                    showMessage();
                }());
                </code></pre>
            </section>

            <section>
                <h3>Lodash, jQuery (and many others...)</h3>
                <table style="width:100%;">
                    <tr>
                        <td>
                <pre class="fragment fade-up"><code class="hljs typescript data-trim has-highlights">
  ;(function() {
  // lodash - main function
  function lodash(value) {
    // ...
  }

  // aux variable
  var version = '2.4.1';

  // encapsulated function code
  function size(collection) {
    return Object.keys(collection).length;
  }

  // define all the exported functions
  lodash.size = size
  // lodash.defaults = ...
  // lodash.cloneDeep = ...

  // export lodash outside
  window._ = lodash;
}());
                </code></pre>
                        </td>
                        <td>
                        <pre class="fragment fade-up"><code class="hljs typescript data-trim has-highlights">
var lodash = (function() {

var version;
function size() { ... }

return {
    size: function() { ... }
}

})();
                </code></pre>
                        </td>
                    </tr>
                </table>
                <aside class="notes">
                    <ul>
                        <li>Code</li>
                        <li>: in the beginning</li>
                        <li></li>
                    </ul>
                </aside>
            </section>

            <section>
                <h2>Pros and Cons</h2>
                <table>
                    <tr>
                        <td>
                            <ul class="pros">
                                <li>Encapsulation & Private data</li>
                                <li>Splits code into logical blocks</li>
                                <li>Improves reusability</li>
                            </ul>
                        </td>
                        <td>
                            <ul class="cons">
                                <li>Can't test private data</li>
                                <li>Manual handling of dependencies</li>
                                <li>Outdated</li>
                            </ul>
                        </td>
                    </tr>
                </table>
            </section>
        </section>

        <section>
            <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background">
                <h2>Singleton</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/singleton.png" alt="blinds gif">
                </p>
                <aside class="notes">
                    це породжувальний патерн проектування, який гарантує, що клас має лише один екземпляр, та надає глобальну точку доступу до нього.
                </aside>
            </section>
            <section>
                <h2>Problem</h2>
                <ul>
                    <li class="fragment fade-up">Ensure that a class has just a single instance.</li>
                    <li class="fragment fade-up">Provide a global access point to that instance.</li>
                </ul>

                <aside class="notes">
                    <p><strong>Ensure that a class has just a single instance</strong>. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource—for example, a database or a file.</p>
                    <p>Here’s how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you’ll get the one you already created.</p>

                    <p><strong>Provide a global access point to that instance</strong>. Remember those global variables that you (all right, me) used to store some essential objects? While they’re very handy, they’re also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.</p>
                    <p>Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.</p>
                    <p>There’s another side to this problem: you don’t want the code that solves problem #1 to be scattered all over your program. It’s much better to have it within one class, especially if the rest of your code already depends on it.</p>
                </aside>
            </section>

            <section>
                <h2>Real-world Example</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/government.jpg" alt="blinds gif">
                </p>
            </section>

            <section>
                <h2>Code</h2>
                <pre><code class="hljs typescript data-trim has-highlights">
const logger = (function () {
    let loggerInstance;
    function createInstance() {
        const instance = new Object('Some logger config');
        return instance;
    }
    return {
        getInstance: function () {
	        // creates instance if it doesn't exist
	        if (!loggerInstance) {
		        loggerInstance = createInstance();
	        }
            return loggerInstance;
        }
        businessLogic: function() {/* ... */}
    };
})();

const logger1 = logger.getInstance();
const logger2 = logger.getInstance();
// Outputs: true
console.log(user1 === user2);
        </code></pre>
            </section>

            <section>
                <h2>Pros and Cons</h2>
                <table>
                    <tr>
                        <td>
                            <ul class="pros">
                                <li>A class has only a single instance</li>
                                <li>Global access point</li>
                                <li>The singleton object is initialized only when it’s requested for the first time</li>
                            </ul>
                        </td>
                        <td>
                            <ul class="cons">
                                <li>Desire to expand functionality</li>
                                <li>Difficulties with testing</li>
                            </ul>
                        </td>
                    </tr>
                </table>
            </section>
        </section>

        <section>
            <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background">
                <h2>Composite</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/composite-2x.png" alt="blinds gif">
                </p>
                <aside class="notes">
                    це структурний патерн проектування, що дає змогу згрупувати декілька об’єктів у деревоподібну структуру, а потім працювати з нею так, ніби це одиничний об’єкт.
                </aside>
            </section>

            <section>
                <h2>Problem</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/composite-problem.png" alt="blinds gif">
                </p>
            </section>

            <section>
                <h2>Solution</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/composite-solution.png" alt="blinds gif">
                </p>
            </section>

            <section>
                <h2>Real world example</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/composite-exapmle.png" alt="blinds gif">
                </p>
            </section>

            <section>
                <pre><code class="hljs typescript data-trim has-highlights">
abstract class Component {
    protected parent: Component;

    public setParent(parent: Component) {
        this.parent = parent;
    }

    public getParent(): Component {
        return this.parent;
    }

    // Child methods (empty in leafs)
    public add(component: Component): void { }
    public remove(component: Component): void { }

    // Optional method to determine if a component can have children
    public isComposite(): boolean {
        return false;
    }

    public getPrice(): number {
         //...
    };
}

class Leaf extends Component {
    constructor(private price: number) {}

    public getPrice(): number {
        return this.price;
    }
}

class Composite extends Component {
    protected children: Component[] = [];

    public add(component: Component): void {
        this.children.push(component);
        component.setParent(this);
    }

    public remove(component: Component): void {
        const componentIndex = this.children.indexOf(component);
        this.children.splice(componentIndex, 1);

        component.setParent(null);
    }

    public isComposite(): boolean {
        return true;
    }

    public getPrice(): string {
        const result: number = 0;
        for (const child of this.children) {
            results += child.getPrice();
        }

        return result;
    }
}

const simple = new Leaf();
console.log(simple.getPrice());

const tree = new Composite();
const branch1 = new Composite();
branch1.add(new Leaf());
branch1.add(new Leaf());
const branch2 = new Composite();
branch2.add(new Leaf());
tree.add(branch1);
tree.add(branch2);
console.log(tree);
                </code></pre>

            </section>

            <section>
                <h2>Pros and Cons</h2>
                <table>
                    <tr>
                        <td>
                            <ul class="pros">
                                <li>Convenient work with complex tree structures</li>
                                <li>Ability to easily introduce new components</li>
                            </ul>
                        </td>
                        <td>
                            <ul class="cons">
                                <li>Sometimes Component interfaces are overgeneralized</li>
                            </ul>
                        </td>
                    </tr>
                </table>
            </section>
        </section>

        <section>
            <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background">
                <h2>Facade</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/facade-2x.png" alt="blinds gif">
                </p>
            </section>

            <section>
                <h3>Problem</h3>
                <table>
                    <tr>
                        <td>
                            <p class="stretch">
                                <img class="plain" src="img/js-patterns/facade-problem.jpg" alt="blinds gif">
                            </p>
                        </td>
                        <td class="fragment fade-left">
                            <p class="stretch">
                                <img class="plain" src="img/js-patterns/facade_solution.jpg" alt="blinds gif">
                            </p>
                        </td>
                    </tr>
                </table>
            </section>

            <section>
                <h2>Real world example</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/facade-epxample.png" alt="blinds gif">
                </p>
            </section>

            <section>
                <pre><code class="hljs typescript data-trim has-highlights">
class Facade {
    protected subsystem1: Subsystem1;
    protected subsystem2: Subsystem2;

    constructor(subsystem1: Subsystem1 = null, subsystem2: Subsystem2 = null) {
        this.subsystem1 = subsystem1 || new Subsystem1();
        this.subsystem2 = subsystem2 || new Subsystem2();
    }

    public operation(): string {
        result += this.subsystem1.operation1();
        result += this.subsystem2.operation1();
        // ...
        result += this.subsystem1.operationN();
        result += this.subsystem2.operationZ();

        return result;
    }
}

class Subsystem1 {
    public operation1(): string {
        return 'Subsystem1: Ready!\n';
    }
    // ...
    public operationN(): string {
        return 'Subsystem1: Go!\n';
    }
}

class Subsystem2 {
    public operation1(): string {
        return 'Subsystem2: Get ready!\n';
    }
    // ...
    public operationZ(): string {
        return 'Subsystem2: Fire!';
    }
}

const subsystem1 = new Subsystem1();
const facade = new Facade(subsystem1);
console.log(facade.operation());
                </code></pre>

            </section>

            <section>
                <h2>Pros and Cons</h2>
                <table>
                    <tr>
                        <td>
                            <ul class="pros">
                                <li>Isolates your code from complexity of a subsystem</li>
                                <li>Prevents tight coupling with a subsystem</li>
                            </ul>
                        </td>
                        <td>
                            <ul class="cons">
                                <li>Can become <strong><u>a god object</u></strong> coupled to all classes of an app</li>
                            </ul>
                        </td>
                    </tr>
                </table>
            </section>

        </section>

        <section>
            <section data-background="./img/js-patterns/pattern-bg.jpg" data-state="dim-background">
                <h2>Strategy</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/strategy-2x.png" alt="blinds gif">
                </p>
                <aside class="notes">
                    це поведінковий патерн проектування, який визначає сімейство схожих алгоритмів і розміщує кожен з них у власному класі. Після цього алгоритми можна заміняти один на інший прямо під час виконання програми.
                </aside>
            </section>

            <section>
                <h2>Problem</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/public-transport.jpg" alt="blinds gif">
                </p>
            </section>

            <section>
                <h2>Solution</h2>
                <p class="stretch">
                    <img class="plain" src="img/js-patterns/startegy-solution.png" alt="blinds gif">
                </p>
            </section>

            <section>
                <pre><code class="hljs typescript data-trim has-highlights">
class Context {
    private strategy: Strategy;

    constructor(strategy: Strategy) {
        this.strategy = strategy;
    }

    public setStrategy(strategy: Strategy) {
        this.strategy = strategy;
    }

    public doSomeBusinessLogic(): void {
        // ...
        console.log('Context: Sorting data using the strategy (not sure how it\'ll do it)');
        const result = this.strategy.doAlgorithm(['a', 'b', 'c', 'd', 'e']);
        console.log(result.join(','));
        // ...
    }
}

interface Strategy {
    doAlgorithm(data: string[]): string[];
}

class ConcreteStrategyA implements Strategy {
    public doAlgorithm(data: string[]): string[] {
        return data.sort();
    }
}

class ConcreteStrategyB implements Strategy {
    public doAlgorithm(data: string[]): string[] {
        return data.reverse();
    }
}
// client code
const context = new Context(new ConcreteStrategyA());
context.doSomeBusinessLogic();

context.setStrategy(new ConcreteStrategyB());
context.doSomeBusinessLogic();
                </code></pre>
            </section>

            <section>
                <h2>Pros and Cons</h2>
                <table>
                    <tr>
                        <td>
                            <ul class="pros">
                                <li>Allows to swap algorithms used inside an object on the fly.</li>
                                <li>Isolates the implementation details of an algorithm from the code that uses it.</li>
                                <li>Allows to add new strategies without changes to the main class.</li>
                            </ul>
                        </td>
                        <td>
                            <ul class="cons">
                                <li>May be to complicated a simple app and be replaced with just functions that are passed to the main algorithm.</li>
                                <li>Client must be aware of different strategies to select a proper one.</li>
                            </ul>
                        </td>
                    </tr>
                </table>
            </section>

        </section>

        <section>
            <blockquote>
                If all you have is a hammer, everything looks like a nail.
            </blockquote>
            <aside class="notes">
                Поширена проблема новачків і не тільки. Як тільки вивчаєш якийсь паттерн, заразу здається, що він вам точно потрібний.
            </aside>
        </section>

        <!--    </section>-->

        <section>
            <h2>Further reading</h2>
            <ul>
                <li>https://refactoring.guru/design-patterns</li>
                <li>Дизайн-патерни — просто, як двері. Андрій Будай</li>
                <li>http://sourcemaking.com/</li>
            </ul>
        </section>

        <section>
            <h2>Questions?</h2>
            <img src="img/angular_bad_pract/end.gif" alt="thanks" class="plain">
        </section>
    </div>

</div>

<script src="js/reveal.js"></script>

<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        transition: 'none',
        controls: false,
        hash: true,
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {src: 'plugin/highlight/highlight.js', async: false}
        ],
    });

</script>
</body>
</html>
